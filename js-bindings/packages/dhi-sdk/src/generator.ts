/**
 * SDK Generator - Generates TypeScript SDK from extracted routes
 *
 * Generates:
 * - Type definitions from dhi schemas
 * - Fetch-based API client
 * - OpenAPI spec (optional)
 */

import type {
  ExtractedAPI,
  ExtractedRoute,
  ExtractedSchema,
  GenerateOptions,
  GeneratedSDK,
  HttpMethod,
} from './types';

export class SDKGenerator {
  private api: ExtractedAPI;
  private options: GenerateOptions;

  constructor(api: ExtractedAPI, options: GenerateOptions) {
    this.api = api;
    this.options = options;
  }

  /**
   * Generate the complete SDK
   */
  generate(): GeneratedSDK {
    const types = this.generateTypes();
    const client = this.generateClient();
    const index = this.generateIndex();
    const openapi = this.options.openapi ? this.generateOpenAPI() : undefined;

    return { types, client, index, openapi };
  }

  /**
   * Generate TypeScript type definitions
   */
  private generateTypes(): string {
    const lines: string[] = [
      '/**',
      ' * Auto-generated TypeScript types',
      ' * Generated by dhi-sdk from Hono app',
      ' */',
      '',
    ];

    // Generate types for each route's schemas
    const routeTypes = new Map<string, string>();

    for (const route of this.api.routes) {
      const routeName = this.routeToTypeName(route);

      // Request body type
      if (route.bodySchema) {
        const typeName = `${routeName}Request`;
        const typeCode = this.schemaToType(route.bodySchema, typeName);
        if (!routeTypes.has(typeName)) {
          routeTypes.set(typeName, typeCode);
        }
      }

      // Query params type
      if (route.querySchema) {
        const typeName = `${routeName}Query`;
        const typeCode = this.schemaToType(route.querySchema, typeName);
        if (!routeTypes.has(typeName)) {
          routeTypes.set(typeName, typeCode);
        }
      }

      // Response type
      if (route.responseSchema) {
        const typeName = `${routeName}Response`;
        const typeCode = this.schemaToType(route.responseSchema, typeName);
        if (!routeTypes.has(typeName)) {
          routeTypes.set(typeName, typeCode);
        }
      }

      // Path params type
      if (route.pathParams.length > 0) {
        const typeName = `${routeName}Params`;
        const paramsType = `export interface ${typeName} {\n${
          route.pathParams.map(p => `  ${p}: string;`).join('\n')
        }\n}`;
        if (!routeTypes.has(typeName)) {
          routeTypes.set(typeName, paramsType);
        }
      }
    }

    // Add named schemas
    for (const [name, schema] of this.api.schemas) {
      const typeCode = this.schemaToType(schema, name);
      routeTypes.set(name, typeCode);
    }

    lines.push(...routeTypes.values());
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Convert schema to TypeScript type definition
   */
  private schemaToType(schema: ExtractedSchema, name: string): string {
    switch (schema.type) {
      case 'object':
        return this.objectSchemaToType(schema, name);
      case 'enum':
        return `export type ${name} = ${schema.tsType || 'string'};`;
      case 'array':
        return `export type ${name} = ${schema.tsType || 'unknown[]'};`;
      case 'union':
      case 'discriminatedUnion':
        return `export type ${name} = ${schema.tsType || 'unknown'}; // TODO: Extract union variants`;
      default:
        return `export type ${name} = ${schema.tsType || 'unknown'};`;
    }
  }

  /**
   * Convert object schema to TypeScript interface
   */
  private objectSchemaToType(schema: ExtractedSchema, name: string): string {
    if (!schema.properties) {
      return `export interface ${name} {\n  [key: string]: unknown;\n}`;
    }

    const lines: string[] = [`export interface ${name} {`];

    for (const [propName, prop] of Object.entries(schema.properties)) {
      const optional = prop.optional ? '?' : '';
      const type = this.schemaTypeToTsType(prop.type);
      const comment = prop.description ? `  /** ${prop.description} */\n` : '';
      lines.push(`${comment}  ${propName}${optional}: ${type};`);
    }

    lines.push('}');
    return lines.join('\n');
  }

  /**
   * Convert schema type to TypeScript type
   */
  private schemaTypeToTsType(type: string): string {
    switch (type) {
      case 'string': return 'string';
      case 'number': return 'number';
      case 'boolean': return 'boolean';
      case 'array': return 'unknown[]';
      case 'object': return 'Record<string, unknown>';
      default: return 'unknown';
    }
  }

  /**
   * Generate the API client
   */
  private generateClient(): string {
    const sdkName = this.options.name || 'api';
    const lines: string[] = [
      '/**',
      ' * Auto-generated API Client',
      ' * Generated by dhi-sdk from Hono app',
      ' */',
      '',
      'import type * as Types from \'./types\';',
      '',
      'export interface ClientConfig {',
      '  baseUrl: string;',
      '  headers?: Record<string, string>;',
      '  fetch?: typeof fetch;',
      '}',
      '',
      'export interface RequestOptions {',
      '  headers?: Record<string, string>;',
      '  signal?: AbortSignal;',
      '}',
      '',
      'export interface ApiResponse<T> {',
      '  data: T;',
      '  status: number;',
      '  headers: Headers;',
      '}',
      '',
      'export class ApiError extends Error {',
      '  constructor(',
      '    public status: number,',
      '    public statusText: string,',
      '    public body: unknown',
      '  ) {',
      '    super(`API Error: ${status} ${statusText}`);',
      '    this.name = \'ApiError\';',
      '  }',
      '}',
      '',
    ];

    // Group routes by resource
    const resources = this.groupRoutesByResource();

    // Generate client class
    lines.push(`export function createClient(config: ClientConfig) {`);
    lines.push('  const baseUrl = config.baseUrl.replace(/\\/$/, \'\');');
    lines.push('  const defaultHeaders = config.headers || {};');
    lines.push('  const fetchFn = config.fetch || fetch;');
    lines.push('');
    lines.push('  async function request<T>(');
    lines.push('    method: string,');
    lines.push('    path: string,');
    lines.push('    options: {');
    lines.push('      body?: unknown;');
    lines.push('      query?: Record<string, string | number | boolean | undefined>;');
    lines.push('      headers?: Record<string, string>;');
    lines.push('      signal?: AbortSignal;');
    lines.push('    } = {}');
    lines.push('  ): Promise<ApiResponse<T>> {');
    lines.push('    const url = new URL(baseUrl + path);');
    lines.push('');
    lines.push('    if (options.query) {');
    lines.push('      for (const [key, value] of Object.entries(options.query)) {');
    lines.push('        if (value !== undefined) {');
    lines.push('          url.searchParams.set(key, String(value));');
    lines.push('        }');
    lines.push('      }');
    lines.push('    }');
    lines.push('');
    lines.push('    const response = await fetchFn(url.toString(), {');
    lines.push('      method,');
    lines.push('      headers: {');
    lines.push('        \'Content-Type\': \'application/json\',');
    lines.push('        ...defaultHeaders,');
    lines.push('        ...options.headers,');
    lines.push('      },');
    lines.push('      body: options.body ? JSON.stringify(options.body) : undefined,');
    lines.push('      signal: options.signal,');
    lines.push('    });');
    lines.push('');
    lines.push('    if (!response.ok) {');
    lines.push('      const body = await response.text().catch(() => null);');
    lines.push('      throw new ApiError(response.status, response.statusText, body);');
    lines.push('    }');
    lines.push('');
    lines.push('    const data = await response.json() as T;');
    lines.push('    return { data, status: response.status, headers: response.headers };');
    lines.push('  }');
    lines.push('');

    // Generate resource objects
    lines.push('  return {');

    for (const [resource, routes] of resources) {
      lines.push(`    ${resource}: {`);

      for (const route of routes) {
        const methodCode = this.generateRouteMethod(route);
        lines.push(methodCode);
      }

      lines.push('    },');
    }

    lines.push('  };');
    lines.push('}');
    lines.push('');
    lines.push('export type Client = ReturnType<typeof createClient>;');

    return lines.join('\n');
  }

  /**
   * Generate method for a single route
   */
  private generateRouteMethod(route: ExtractedRoute): string {
    const methodName = this.routeToMethodName(route);
    const typeName = this.routeToTypeName(route);

    // Build parameter list
    const params: string[] = [];
    const hasPathParams = route.pathParams.length > 0;
    const hasBody = route.bodySchema && ['POST', 'PUT', 'PATCH'].includes(route.method);
    const hasQuery = !!route.querySchema;

    if (hasPathParams) {
      params.push(`params: Types.${typeName}Params`);
    }
    if (hasBody) {
      params.push(`body: Types.${typeName}Request`);
    }
    if (hasQuery) {
      params.push(`query?: Types.${typeName}Query`);
    }
    params.push('options?: RequestOptions');

    // Build path with interpolation
    let pathExpr = `'${route.path}'`;
    if (hasPathParams) {
      pathExpr = '`' + route.path.replace(/:(\w+)/g, '${params.$1}') + '`';
    }

    // Build request options
    const requestOpts: string[] = [];
    if (hasBody) requestOpts.push('body');
    if (hasQuery) requestOpts.push('query');
    requestOpts.push('...options');

    const responseType = route.responseSchema ? `Types.${typeName}Response` : 'unknown';

    return [
      `      /**`,
      `       * ${route.method} ${route.path}`,
      `       */`,
      `      async ${methodName}(${params.join(', ')}): Promise<ApiResponse<${responseType}>> {`,
      `        return request<${responseType}>('${route.method}', ${pathExpr}, { ${requestOpts.join(', ')} });`,
      `      },`,
    ].join('\n');
  }

  /**
   * Group routes by resource (first path segment)
   */
  private groupRoutesByResource(): Map<string, ExtractedRoute[]> {
    const resources = new Map<string, ExtractedRoute[]>();

    for (const route of this.api.routes) {
      const segments = route.path.split('/').filter(Boolean);
      const resource = segments[0] || 'root';

      if (!resources.has(resource)) {
        resources.set(resource, []);
      }
      resources.get(resource)!.push(route);
    }

    return resources;
  }

  /**
   * Convert route to type name (PascalCase)
   */
  private routeToTypeName(route: ExtractedRoute): string {
    const segments = route.path
      .split('/')
      .filter(s => s && !s.startsWith(':'))
      .map(s => s.charAt(0).toUpperCase() + s.slice(1));

    const method = route.method.charAt(0) + route.method.slice(1).toLowerCase();

    return segments.join('') + method;
  }

  /**
   * Convert route to method name (camelCase)
   */
  private routeToMethodName(route: ExtractedRoute): string {
    const segments = route.path.split('/').filter(s => s && !s.startsWith(':'));

    // Use last segment as primary name
    const primary = segments[segments.length - 1] || 'index';

    // Map HTTP method to action
    const actions: Record<HttpMethod, string> = {
      GET: route.pathParams.length > 0 ? 'get' : 'list',
      POST: 'create',
      PUT: 'update',
      PATCH: 'patch',
      DELETE: 'delete',
    };

    const action = actions[route.method];

    // Handle common patterns
    if (primary === segments[0] && route.pathParams.length === 0) {
      return action;
    }

    return action + primary.charAt(0).toUpperCase() + primary.slice(1);
  }

  /**
   * Generate index.ts exports
   */
  private generateIndex(): string {
    return [
      '/**',
      ' * Auto-generated SDK exports',
      ' * Generated by dhi-sdk from Hono app',
      ' */',
      '',
      'export * from \'./types\';',
      'export * from \'./client\';',
      '',
    ].join('\n');
  }

  /**
   * Generate OpenAPI 3.1 spec
   */
  private generateOpenAPI(): object {
    const paths: Record<string, Record<string, object>> = {};

    for (const route of this.api.routes) {
      const openApiPath = route.path.replace(/:(\w+)/g, '{$1}');

      if (!paths[openApiPath]) {
        paths[openApiPath] = {};
      }

      const operation: Record<string, unknown> = {
        operationId: this.routeToMethodName(route),
        responses: {
          '200': {
            description: 'Successful response',
            content: {
              'application/json': {
                schema: route.responseSchema?.jsonSchema || { type: 'object' },
              },
            },
          },
        },
      };

      // Add parameters
      const parameters: object[] = [];

      for (const param of route.pathParams) {
        parameters.push({
          name: param,
          in: 'path',
          required: true,
          schema: { type: 'string' },
        });
      }

      if (parameters.length > 0) {
        operation.parameters = parameters;
      }

      // Add request body
      if (route.bodySchema && ['POST', 'PUT', 'PATCH'].includes(route.method)) {
        operation.requestBody = {
          required: true,
          content: {
            'application/json': {
              schema: route.bodySchema.jsonSchema || { type: 'object' },
            },
          },
        };
      }

      paths[openApiPath][route.method.toLowerCase()] = operation;
    }

    return {
      openapi: '3.1.0',
      info: {
        title: this.options.name || 'API',
        version: '1.0.0',
      },
      servers: this.options.baseUrl ? [{ url: this.options.baseUrl }] : [],
      paths,
    };
  }
}
